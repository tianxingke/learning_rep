1.xml标签对大小写敏感。

2.在 XML 中，XML 的属性 值 须加引号，单双引号都可以。 要是属性值里边有双引号，那就要用单引号包围或者是使用实体引用。
	<gangster name='George "Shotgun" Ziegler'>
	或者可以使用实体引用：
	<gangster name="George &quot;Shotgun&quot; Ziegler">

3.实体引用
	在 XML 中，一些字符拥有特殊的意义。
	如果你把字符 "<" 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。
	这样会产生 XML 错误：<message>if salary < 1000 then</message>
	为了避免这个错误，请用实体引用来代替 "<" 字符：<message>if salary &lt; 1000 then</message>
	在 XML 中，有 5 个预定义的实体引用：
	&lt;	<	小于
	&gt;	>	大于
	&amp;	&	和号
	&apos;	'	单引号
	&quot;	"	引号
	注释：在 XML 中，只有字符 "<" 和 "&" 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。


4.DTD
	内部的 DOCTYPE 声明
	假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：
	<!DOCTYPE 根元素 [元素声明]>
	带有 DTD 的 XML 文档实例（请在 IE5 以及更高的版本打开，并选择查看源代码）：
	<?xml version="1.0"?>
	<!DOCTYPE note [
	  <!ELEMENT note (to,from,heading,body)>
	  <!ELEMENT to      (#PCDATA)>
	  <!ELEMENT from    (#PCDATA)>
	  <!ELEMENT heading (#PCDATA)>
	  <!ELEMENT body    (#PCDATA)>
	]>
	<note>
	  <to>George</to>
	  <from>John</from>
	  <heading>Reminder</heading>
	  <body>Don't forget the meeting!</body>
	</note>
	
	以上 DTD 解释如下：
	!DOCTYPE note (第二行)定义此文档是 note 类型的文档。
	!ELEMENT note (第三行)定义 note 元素有四个元素："to、from、heading,、body"
	!ELEMENT to (第四行)定义 to 元素为 "#PCDATA" 类型
	!ELEMENT from (第五行)定义 from 元素为 "#PCDATA" 类型
	!ELEMENT heading (第六行)定义 heading 元素为 "#PCDATA" 类型
	!ELEMENT body (第七行)定义 body 元素为 "#PCDATA" 类型
	
	PCDATA 的意思是被解析的字符数据（parsed character data）。
	可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。
	CDATA 的意思是字符数据（character data）。
	CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。
		
		
	DTD 文件
	下面这个例子是名为 "note.dtd" 的 DTD 文件，它对上面那个 XML 文档的元素进行了定义：
	<!ELEMENT note (to, from, heading, body)>
	<!ELEMENT to (#PCDATA)>
	<!ELEMENT from (#PCDATA)>
	<!ELEMENT heading (#PCDATA)>
	<!ELEMENT body (#PCDATA)>	
	
	对 DTD 的引用
	此文件包含对 DTD 的引用：
	<?xml version="1.0"?>
	<!DOCTYPE note SYSTEM "http://www.w3school.com.cn/dtd/note.dtd">
	<note>
	<to>George</to>
	<from>John</from>
	<heading>Reminder</heading>
	<body>Don't forget the meeting!</body>
	</note>

	
	
5.XML Schema
	W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema。
	XML Schema 的作用是定义 XML 文档的合法构建模块，类似 DTD。

	XML Schema:
	定义可出现在文档中的元素
	定义可出现在文档中的属性
	定义哪个元素是子元素
	定义子元素的次序
	定义子元素的数目
	定义元素是否为空，或者是否可包含文本
	定义元素和属性的数据类型
	定义元素和属性的默认值以及固定值
	
	下面这个例子是一个名为 "note.xsd" 的 XML Schema 文件，它定义了上面那个 XML 文档的元素：
	<?xml version="1.0"?>
	<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
	targetNamespace="http://www.w3school.com.cn"
	xmlns="http://www.w3school.com.cn"
	elementFormDefault="qualified">

	<xs:element name="note">
		<xs:complexType>
		  <xs:sequence>
		<xs:element name="to" type="xs:string"/>
		<xs:element name="from" type="xs:string"/>
		<xs:element name="heading" type="xs:string"/>
		<xs:element name="body" type="xs:string"/>
		  </xs:sequence>
		</xs:complexType>
	</xs:element>
	</xs:schema>
	
	对 XML Schema 的引用
	此文件包含对 XML Schema 的引用：
	<?xml version="1.0"?>
	<note
	xmlns="http://www.w3school.com.cn"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.w3school.com.cn note.xsd">

	<to>George</to>
	<from>John</from>
	<heading>Reminder</heading>
	<body>Don't forget the meeting!</body>
	</note>
	
	
	
	
6.XSLT 是首选的 XML 样式表语言。

7.XMLHttpRequest 对象
	所有现代的浏览器都支持 XMLHttpRequest 对象。
	创建 XMLHttpRequest 对象的语法：
	xmlhttp=new XMLHttpRequest();
	
	实例 1:
	<script type="text/javascript">
	var xmlhttp;
	function loadXMLDoc(url)
	{
		xmlhttp=null;
		if (window.XMLHttpRequest)
		  {// code for all new browsers
		  xmlhttp=new XMLHttpRequest();
		  }
		else if (window.ActiveXObject)
		  {// code for IE5 and IE6
		  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
		  }
		if (xmlhttp!=null)
		  {
		  xmlhttp.onreadystatechange=state_Change;
		  xmlhttp.open("GET",url,true);
		  xmlhttp.send(null);
		  }
		else
		  {
		  alert("Your browser does not support XMLHTTP.");
		  }
		}

		function state_Change()
		{
		if (xmlhttp.readyState==4)
		  {// 4 = "loaded"
		  if (xmlhttp.status==200)
		    {// 200 = OK
		    // ...our code here...
		    }
		  else
		    {
		    alert("Problem retrieving XML data");
		    }
		  }
	}
	</script>
	注释：onreadystatechange 是一个事件句柄。它的值 (state_Change) 是一个函数的名称，当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。状态从 0 (uninitialized) 到 4 (complete) 进行变化。仅在状态为 4 时，我们才执行代码。
	为什么使用 Async=true ？
	我们的实例在 open() 的第三个参数中使用了 "true"。
	该参数规定请求是否异步处理。
	True 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应。
	onreadystatechange 事件使代码复杂化了。但是这是在没有得到服务器响应的情况下，防止代码停止的最安全的方法。
	通过把该参数设置为 "false"，可以省去额外的 onreadystatechange 代码。如果在请求失败时是否执行其余的代码无关紧要，那么可以使用这个参数。
	

	您也可以把 XML 文档打开并发送到服务器上的 ASP 页面，分析此请求，然后传回结果。
	<html>
	<body>
		<script type="text/javascript">
			xmlHttp=null;
			if (window.XMLHttpRequest)
			  {// code for IE7, Firefox, Opera, etc.
			  xmlHttp=new XMLHttpRequest();
			  }
			else if (window.ActiveXObject)
			  {// code for IE6, IE5
			  xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");
			  }
			if (xmlHttp!=null)
			  {
			  xmlHttp.open("GET", "note.xml", false);
			  xmlHttp.send(null);
			  xmlDoc=xmlHttp.responseText;

			  xmlHttp.open("POST", "demo_dom_http.asp", false);
			  xmlHttp.send(xmlDoc);
			  document.write(xmlHttp.responseText);
			  }
			else
			  {
			  alert("Your browser does not support XMLHTTP.");
			  }
		</script>
	</body>
	</html>
	
	
8.解析 XML 文档
	下面的代码片段把 XML 文档解析到 XML DOM 对象中：
	if (window.XMLHttpRequest)
	  {// code for IE7+, Firefox, Chrome, Opera, Safari
	  xmlhttp=new XMLHttpRequest();
	  }
	else
	  {// code for IE6, IE5
	  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	  }

	xmlhttp.open("GET","books.xml",false);
	xmlhttp.send();
	xmlDoc=xmlhttp.responseXML; 
	
	其他方法 1：通过微软的 XML 解析器来加载 XML
	微软的 XML 解析器内建于 Internet Explorer 5 以及更高的版本中。
	下面的 JavaScript 片段把一个 XML 文档载入解析器中：
	var xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
	xmlDoc.async="false";
	xmlDoc.load("note.xml");
	上面代码的第一个行创建一个空的微软 XML 文档对象。
	第二行关闭异步加载，这样确保在文档完全加载之前解析器不会继续脚本的执行。
	第三行告知解析器加载名为 "note.xml" 的 XML 文档。
	
	其他方法 2：在 Firefox 及其他浏览器中的 XML 解析器
	下面的 JavaScript 片段把 XML 文档 ("note.xml") 载入解析器：
	var xmlDoc=document.implementation.createDocument("","",null);
	xmlDoc.async="false";
	xmlDoc.load("note.xml");
	上面代码的第一个行创建一个空的 XML 文档对象。
	第二行关闭异步加载，这样确保在文档完全加载之前解析器不会继续脚本的执行。
	第三行告知解析器加载名为 "note.xml" 的 XML 文档。
	
	解析 XML 字符串
	下面的 JavaScript 代码片段把 XML 字符串解析到 XML DOM 对象中（把字符串 txt 载入解析器）：
	txt="<bookstore><book>";
	txt=txt+"<title>Everyday Italian</title>";
	txt=txt+"<author>Giada De Laurentiis</author>";
	txt=txt+"<year>2005</year>";
	txt=txt+"</book></bookstore>";

	if (window.DOMParser)
	  {
	  parser=new DOMParser();
	  xmlDoc=parser.parseFromString(txt,"text/xml");
	  }
	else // Internet Explorer
	  {
	  xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
	  xmlDoc.async="false";
	  xmlDoc.loadXML(txt);
	  }
	注释：Internet Explorer 使用 loadXML() 方法来解析 XML 字符串，而其他浏览器使用 DOMParser 对象。
	注释：loadXML() 方法用于加载字符串（文本），load() 用于加载文件。
	
	
9.DOM （Document Object Model，文档对象模型）定义了访问和操作文档的标准方法。
	解析 XML 文件 - 跨浏览器实例
	下列代码把一个 XML 文档 ("note.xml") 载入 XML 解析器中：
	<html>
	<body>
	<h1>W3School.com.cn Internal Note</h1>
	<p><b>To:</b> <span id="to"></span><br />
	<b>From:</b> <span id="from"></span><br />
	<b>Message:</b> <span id="message"></span>

	<script type="text/javascript">
	if (window.XMLHttpRequest)
	  {// code for IE7+, Firefox, Chrome, Opera, Safari
	  xmlhttp=new XMLHttpRequest();
	  }
	else
	  {// code for IE6, IE5
	  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	  }
	xmlhttp.open("GET","note.xml",false);
	xmlhttp.send();
	xmlDoc=xmlhttp.responseXML;

	document.getElementById("to").innerHTML=
	xmlDoc.getElementsByTagName("to")[0].childNodes[0].nodeValue;

	document.getElementById("from").innerHTML=
	xmlDoc.getElementsByTagName("from")[0].childNodes[0].nodeValue;

	document.getElementById("message").innerHTML=
	xmlDoc.getElementsByTagName("body")[0].childNodes[0].nodeValue;
	</script>

	</body>
	</html>
	
	
10.XML 命名空间提供避免元素命名冲突的方法。	
	使用命名空间（Namespaces）
	这个 XML 文档携带着某个表格中的信息：
	<h:table xmlns:h="http://www.w3.org/TR/html4/">
	   <h:tr>
	   <h:td>Apples</h:td>
	   <h:td>Bananas</h:td>
	   </h:tr>
	</h:table>
	此 XML 文档携带着有关一件家具的信息：
	<f:table xmlns:f="http://www.w3school.com.cn/furniture">
	   <f:name>African Coffee Table</f:name>
	   <f:width>80</f:width>
	   <f:length>120</f:length>
	</f:table>
	与仅仅使用前缀不同，我们为 <table> 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。	
	
	
11.术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。
	某些文本，比如 JavaScript 代码，包含大量 "<" 或 "&" 字符。为了避免错误，可以将脚本代码定义为 CDATA。
	CDATA 部分中的所有内容都会被解析器忽略。
	CDATA 部分由 "<![CDATA[" 开始，由 "]]>" 结束：
	<script>
	<![CDATA[
	function matchwo(a,b)
	{
	if (a < b && a < 0) then
	  {
	  return 1;
	  }
	else
	  {
	  return 0;
	  }
	}
	]]>
	</script>
	关于 CDATA 部分的注释：
	CDATA 部分不能包含字符串 "]]>"。也不允许嵌套的 CDATA 部分。
	标记 CDATA 部分结尾的 "]]>" 不能包含空格或折行。
		
	