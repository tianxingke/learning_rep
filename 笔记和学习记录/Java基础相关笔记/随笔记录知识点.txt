一、基本类型
	int
	int默认值为0，Interge默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。声明为int的变量不需要实例化，声明为Interger的变量需要实例化。
	基本数据类型和对象比较的时候，对象会自动拆箱为基本数据类型再比较,比较的就是里面的值而不是地址。
	int基本类型之间的比较是值的比较。

	情况1）:
	Integer e = new Integer(127);
	Integer f = new Integer(127);
	System.out.println(e==f);   //false

	Integer a = new Integer(127);	
	Integer b = 127;
	System.out.println(a==b); //false
	此种情况时两个new的对象间的比较，比较的是对象的地址。
	
	情况2）:
		Integer a = new Integer(127);	
		Integer b = 127;
		int c=127;
		System.out.println(a==b);	//false
		System.out.println(b==c);	//true
		System.out.println(a==c);	//true
		
		Integer e = new Integer(128);	
		Integer f = 128;
		int g=127;
		System.out.println(e==f);	//false
		System.out.println(f==g);	//true	
		System.out.println(e==g);	//true
	此种情况下，对象比较同上。b与c，f与g比较时，b、f自动拆箱，变成int b=127，int f=128 然后分别进行比较，比较的是值。

	情况3）:
		Integer a=127;
		Integer b=127;
		Integer c=128;
		Integer d=128;
		
		System.out.println(a==b);	//true
		System.out.println(c==d);	//false

	此种情况下，自动装箱为对象，如果值在[-128~127]之间，则取缓存的值，否则重新创建对象。

	
二、String
	new对象和常量池的概念
	java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。但是两种浮点数类型的包装类Float,Double并没有实现常量池技术。
	情况1）:
		String a = "123";
		String b = "123";
		System.out.println(a == b);	//true
		在java中，字符串字面值是常量，所以保存在常量池中，而不是堆栈里。a与b的值是在常量池中，且是一个，赋值时先在常量池中查找是否有这个值，如果有则不创建新的。

	情况2）:
		String c = new String("456");
		String d = new String("456");
		System.out.println(c == d);	//false
		是new的，存在堆中，是地址不同的对象。

	情况3）:
		String e = "789";
		String f = new String("789");
		System.out.println(e == f);	//false
		e在常量池中，f在堆中，地址不一样。

	情况4）:
		String str1 = "str";
		String str2 = "ing";

		String str3 = "str" + "ing";
		String str4 = str1 + str2;
		System.out.println(str3 == str4);	//false

		String str5 = "string";
		System.out.println(str3 == str5);	//true
		System.out.println(str4 ==str5);	//false

	（1）只有使用引号包含文本的方式创建的String对象之间使用“+”连接，产生的新对象才会被加入字符串池中。
	（2）对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。

		特例：
		public class Test01 {
			final static String a = "123";
			final static String b = "456";

			public static void main(String[] args) {

				String c = a + b;
				String d = "123456";
				System.out.println(c == d);	//true
			}
		}
		a和b都是常量，值是固定的，因此c的值也是固定的，它在类被编译时就已经确定了。如果a，b延迟赋值则结果就是false。

	String s1 = new String("xyz"); 创建了几个实例？
	有人说两个？有人说jdk1.6以及以前会将字符串实例复制到永久代中，jdk1.7后改为复制实例的引用。

三、数组
	int[] a = new int[10];
	System.out.println(a.getClass().getName());	//[I [代表了维度
	数组也是一个对象，是object的直接子类。

	//初始化的方法：
	int b[] = new int[] {1,2,3,4,5};    
        int c[] = {1,2,3,4,5};

	通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。
	
	拷贝：
	Object的clone()方法：
		clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：

	      1、 基本类型
		 如果变量是基本很类型，则拷贝其值，比如int、float等。
	      2、 对象
		 如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。
	      3、 String字符串
		 若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。
	
	数组转换list问题：
	Arrays这个工具的asList()方法将其转换成列表list，会出问题。asList的参数是泛型的，但八中基本数据类型无法使用泛型，因此，参数就成了int[]类型的了。结果输出为1.如果将int改为Integer，则长度就会变成数组的长度了。
	asList()返回的是一个不可变的列表。无法add和remove。
	

四、Java并发多线程
	1.多线程问题：https://www.shiyanlou.com/questions/2793
	http://www.cnblogs.com/xrq730/category/733883.html

	2.创建线程有两种方式：
		1、继承Thread，重写父类的run()方法。
		2、实现Runnable接口。和继承自Thread类差不多，不过实现Runnable后，还是要通过一个Thread来启动

	其实Thread类也是实现的Runnable接口。两种实现方式对比的关键就在于extends和implements的对比，当然是后者好。因为第一，继承只能但继承，实现可以多实现；第二，实现的方式对比继承的方式，也有利于减小程序之间的耦合。


	3.线程状态
	虚拟机中的线程状态有六种，定义在Thread.State中：

		1、新建状态NEW

		new了但是没有启动的线程的状态。比如"Thread t = new Thread()"，t就是一个处于NEW状态的线程

		2、可运行状态RUNNABLE

		new出来线程，调用start()方法即处于RUNNABLE状态了。处于RUNNABLE状态的线程可能正在Java虚拟机中运行，也可能正在等待处理器的资源，因为一个线程必须获得CPU的资源后，才可以运行其run()方法中的内容，否则排队等待

		3、阻塞BLOCKED

		如果某一线程正在等待监视器锁，以便进入一个同步的块/方法，那么这个线程的状态就是阻塞BLOCKED

		4、等待WAITING

		某一线程因为调用不带超时的Object的wait()方法、不带超时的Thread的join()方法、LockSupport的park()方法，就会处于等待WAITING状态

		5、超时等待TIMED_WAITING

		某一线程因为调用带有指定正等待时间的Object的wait()方法、Thread的join()方法、Thread的sleep()方法、LockSupport的parkNanos()方法、LockSupport的parkUntil()方法，就会处于超时等待TIMED_WAITING状态

		6、终止状态TERMINATED

		线程调用终止或者run()方法执行结束后，线程即处于终止状态。处于终止状态的线程不具备继续运行的能力

	4.Thread类中的方法调用方式：	
		学习Thread类中的方法是学习多线程的第一步。在学习多线程之前特别提出一点，调用Thread中的方法的时候，在线程类中，有两种方式，一定要理解这两种方式的区别：
		1、this.XXX()
		这种调用方式表示的线程是线程实例本身
		2、Thread.currentThread.XXX()或Thread.XXX()
		上面两种写法是一样的意思。这种调用方式表示的线程是正在执行Thread.currentThread.XXX()所在代码块的线程

		Thread.currentThread().getName()
		isAlive()
		getId()
		getName()
		getPriority()和setPriority(int newPriority)
		线程默认优先级为5，如果不手动指定，那么线程优先级具有继承性，比如线程A启动线程B，那么线程B的优先级和线程A的优先级相同。
		isDaeMon、setDaemon(boolean on)
		讲解两个方法前，首先要知道理解一个概念。Java中有两种线程，一种是用户线程，一种是守护线程。守护线程是一种特殊的线程，它的作用是为其他线程的运行提供便利的服务，最典型的应用便是GC线程。如果进程中不存在非守护线程了，那么守护线程自动销毁，因为没有存在的必要，为别人服务，结果服务的对象都没了，当然就销毁了。
		关于守护线程，有一个细节注意下，setDaemon(true)必须在线程start()之前
		interrupt()
		这是一个有点误导性的名字，实际上Thread类的interrupt()方法无法中断线程。
		interrupt()方法的作用实际上是：在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞状态。换句话说，没有被阻塞的线程，调用interrupt()方法是不起作用的。
		isInterrupted()
		测试线程是否已经中断，但不清除状态标识。
		join()
		join()方法的作用是等待线程销毁。



		wait()/notify()

		


五、原理性的知识体系
	1.foreach循环的原理
		那么为什么是数组或者实现了这个接口，就能实现遍历呢？其实是因为编译器的原因，在编译中的语义分析过程中，有一个解除语法糖的操作，（语法糖是啥？可以理解成编译器为方便开发人员开发，会对特定代码做一些特殊处理，方便开发人员使用，除了foreach，java中还有泛型、装箱、拆箱、变长字符串等）。
		对于list编译器会调用Iterable接口的 iterator方法来循环遍历数组的元素，iterator方法中是调用Iterator接口的的 next()和hasNext（）方法来做循环遍历。java中有一个叫做迭代器模式的设计模式，这个其实就是对迭代器模式的一个实现。
		对于数组，就是转化为对数组中的每一个元素的循环引用


	2.static
		答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。
		

	3.volatile关键字的底层实现原理


	4.集合

	非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。

	集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap，我给网友朋友们提供三点回答或者是研究方向：

	（1）ConcurrentHashMap的锁分段技术

	（2）ConcurrentHashMap的读是否要加锁，为什么

	（3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器

	5.多线程

	这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同，总结起来是这么一个意思：

	假如有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？
	聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。

	另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。

	最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等，
	5、IO

	再次补充IO的内容，之前忘了写了。

	IO分为File IO和Socket IO，File IO基本上是不会问的，问也问不出什么来，平时会用就好了，另外记得File IO都是阻塞IO。

	Socket IO是比较重要的一块，要搞懂的是阻塞/非阻塞的区别、同步/异步的区别，借此理解阻塞IO、非阻塞IO、多路复用IO、异步IO这四种IO模型，Socket IO如何和这四种模型相关联。这是基本一些的，深入一些的话，就会问NIO的原理、NIO属于哪种IO模型、NIO的三大组成等等，这有些难，当时我也是研究了很久才搞懂NIO。提一句，NIO并不是严格意义上的非阻塞IO而应该属于多路复用IO，面试回答的时候要注意这个细节，讲到NIO会阻塞在Selector的select方法上会增加面试官对你的好感。

	如果用过Netty，可能会问一些Netty的东西，毕竟这个框架基本属于当前最好的NIO框架了（Mina其实也不错，不过总体来说还是比不上Netty的），大多数互联网公司也都在用Netty。

	6、JDK源码

	要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。LZ面试过程中被问了不少JDK源码的问题，其中最刁钻的一个问了LZ，String的hashCode()方法是怎么实现的，幸好LZ平时String源代码看得多，答了个大概。JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码：

	（1）List、Map、Set实现类的源代码

	（2）ReentrantLock、AQS的源代码

	（3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的

	（4）线程池的实现原理

	（5）Object类中的方法以及每个方法的作用

	这些其实要求蛮高的，LZ去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的----不仅仅是为了应付面试。

	7、框架

	老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习框架的使用细节自然都不成问题。

	如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。LZ遇到的最变态的是让LZ画一下Spring的Bean工厂实现的UML图，当然面对这样一个有深度的问题，LZ是绝对答不出来的/(ㄒoㄒ)/~~

	8、数据库

	数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把SQL基础和SQL优化的内容准备一下。

	不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。

	9、数据结构和算法分析

	数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和我聊到了数据库的索引，他问我：

	你知道索引使用的是哪种数据结构实现吗？
	LZ答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？LZ答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？

	至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了显示LZ的博学，对算法分析也有一定的研究(⊙﹏⊙)b，LZ还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。

	10、Java虚拟机

	出乎LZ的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，LZ去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践》，LZ就读了不下五遍。

	言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，LZ就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容：

	（1）Java虚拟机的内存布局

	（2）GC算法及几种垃圾收集器

	（3）类加载机制，也就是双亲委派模型

	（4）Java内存模型

	（5）happens-before规则

	（6）volatile关键字使用规则

	也许面试无用，但在走向大牛的路上，不可不会。

	11、Web方面的一些问题

	Java主要面向Web端，因此Web的一些问题也是必问的。LZ碰到过问得最多的两个问题是：

	谈谈分布式Session的几种实现方式
	常用的四种能答出来自然是让面试官非常满意的，另外一个常问的问题是：

	讲一下Session和Cookie的区别和联系以及Session的实现原理
	这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。

	噢，想起来了，一致性Hash算法貌似也被问到了几次，这个LZ以前专门深入研究过并且写了两篇博文，因此问到这个问题LZ自然是答得毫不费力。文章是MemCache超详细解读和对一致性Hash算法，Java代码实现的深入研究，特别说明，LZ真的不是在为自已以前写的文章打广告啊啊啊啊啊啊。

	最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。

	 

	关于HR面试

	如果你过五关斩六将，成功地通过了所有的技术面，那么恭喜你，你离升职加薪、出任CEO、迎娶白富美、走向人生巅峰又进了一步。但是还没有到谈薪资待遇的时候，最后还有一个考验：HR面试。基本所有的大公司都有这一轮的面试，不要小看HR面试，很多公司的HR对于面试者都有一票否决权的----即使前面的面试对你的评价再高。

	所以，这轮的面试也必须重视起来，HR面试主要问的是几点：

	1、简历中写的过去工作经历的离职原因

	2、当前公司薪资待遇

	3、期望能到怎样的一家公司

	4、个人未来的发展方向

	我专门提一下第2点。可能有人比较排斥也不想说这个，我个人倒是持开放状态，问了就说了，当然一些的夸大还是必要的，当前公司薪资待遇多报个一千块钱完全没问题（毕竟是一家互联网公司总多多少少有些补贴啊什么的嘛）。因为这和你在新公司能拿到的薪水关系不大，新公司能拿到的薪水的决定因素是整个公司的薪资情况以及根据你的面试情况在公司的定位，都是有固定的薪资范围的。HR问这个主要也就是心里有个数并且看你是否诚信----有些公司入职时会要求你提供最近一家单位的银行流水号。

	HR面试就说到这里了，总结起来其实就是四个字：滴水不漏。整个面试过程态度积极向上，不要有任何悲观消极的态度（尤其在谈到以前公司情况的时候，即使有再多的不满），就不会有问题。

	 

	关于面试心态

	这个嘛，LZ其实在公司也面试过几个人，一半以上的面试者回答问题的时候都属于那种双腿发抖、声音颤抖的类型。在LZ看来这大可不必并且这还是扣分项，回答问题的时候最最基本的两个要求：

	1、不紧不慢，平心静气

	2、条理清晰

	表达能力绝对是面试的时候重要的考察项目。咱们做的是程序员这一行，讲究的是团队协作，不是写作、画画，一支笔、一个人就行了，一个表达能力不行的程序员，要来又有什么用呢？

	除此之外，就是保持良好的心态。古语说得好，只要功夫深，铁杵磨成针，面试的成功与否，在于平时的积累，临时抱抱佛脚，看两道面试题是没有用的，只要平时足够努力，成功是水到渠成的事情，平时不怎么研究技术的，那也就是个听天由命的事情，只要充分地展示平时自己的所学就可以了。

	因此在我看来，不要把面试当作面试，当做一次技术交流，把面试的心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己，这样就会平和多了，即使失败也不会有太多失望的感觉。

	另外，如果平时自己热衷于研究技术的朋友，真的要有自信，不要觉得别人面试你别人就比你厉害。面试官未必比你优秀，他问的问题往往都是他平时研究得比较多的问题，你一样有很多自己的研究面试官未必知道。

	 

	关于Java

	网上常看到一种说法：Java比较简单。某种程度上这会打击Java程序员的信心----原来咱们平时用的是这种小儿科的玩意儿啊，在我看来这种想法大可不必，这一部分我来讲讲对于这个话题的看法。

	这种说法有些片面，得分开两部分来看，我用四个自总结一下就是：易学难精。

	1、易学部分

	Java易学我认为有两部分的原因：

	（1）很多培训公司包括大四的学生找工作都会学习Java，绝大多数是因为易学。Java从C/C++发展而来，感谢前人的智慧，它消除了C/C++中最复杂和让人困惑的语法、它消除了平台的差异性、它不需要用户手动释放内存空间、它避免了Java程序员和本地语言的交互，让程序员只需要专注于语法层面和应用层面。

	（2）Java作为一门面向对象的语言，在企业级开发中体现出了它无与伦比的特性，整个开发流程比较固定化、模块化，需求分析起来也相对容易。我举个自己以前的例子吧，我在大一学习C语言的时候，用C语言写了一个图书管理系统写了2000行+的代码，大四学了C++之后，用面向对象的语言C++取代面向过程的语言C语言重新写了一个功能相似的图书管理系统，只写了1100行的样子，这就是面向对象的优势。

	2、难精部分

	接着咱们聊聊难精的部分。

	Java语言的设计者帮助Java程序员做了这么多事情，这有利也有弊。有利的部分前面已经说过了，让Java易学，不过有弊的部分同样明显。假如在应用运行过程中遇到了语法层面和应用层面之外的错误，应当如何处理？比如线上环境出现内存溢出怎么办？GC时间过长怎么办？IO长时间没反应怎么办？方法抛出莫名其妙的异常怎么办？

	凡此种种，绝不是一名只会写几个if...else...的Java程序员就可以解决的，这需要大量的经历、大量的实践、大量对Java底层实现细节的研究，而这往往是最难、最考验Java程序员的部分，一些人根本就不想往深去研究，另外一些人研究了一点点就研究不下去了。

	Java为什么难精？就是这个原因。除非你水平特别高，否则五年工作经验以下的Java程序员在简历上写"精通Java"绝对是一件非常愚蠢的事情。

	 



六、技术文章
	五月的仓颉：http://www.cnblogs.com/xrq730/
















































