常用配置：
1.显示GC日志：http://blog.csdn.net/zsy112371/article/details/44981923
2.-XX:+PrintGCDetails 虚拟机在发生垃圾收集时打印内存回收日志
------------------------------------------------------------------------------------------------------------

一、Java虚拟机运行时数据区
1.结构图片http://img.blog.csdn.net/20160801164042333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
2.运行时数据区组成：
	a).程序计数器：可以看作是当前线程所执行的字节码的行号指示器。通过改变这个计数器的值来选取下条要执行的字节码指令。分支、循环、异常等都依赖计数器。
			每个线程都有各自的计数器，互不影响，为私有内存。
			如果线程正在执行的是Java方法，则此计数器记录的是正在执行的字节码指令地址，如果是Native方法则计数器值为空。
			此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
	
	b).java虚拟机栈：Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
	局部变量表存放了编译期可知的各种基本数据类型（8种基本类型）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。
	这个区域有两种异常状态：1）如果线程请求的栈深度大雨虚拟机所允许的深度，将抛出StackOverflowError异常。2）如果动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
	
	c).本地方法栈：本地方法栈为虚拟机使用到的Native方法（字节码）服务。与虚拟机栈一样，也会抛出StackOverflowError和OutOfMemoryError异常。
	
	d).Java堆：java堆是虚拟机内存中最大的一块。是被所有的线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放（几乎所有）对象实例。
	java堆又被称为GC堆。由于现在收集器基本都是采用分代收集算法，所以java堆中可以分为新生代和老年代。从内存分配的角度来看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（TLAB）。
	java堆可以处于物理上不连续的内存空间。可扩展（通过-Xmx和-Xms控制）。
	如果堆中没有内存完成实例分配，并且也无法再扩展时，抛出OutOfMemoryError。

	e).方法区：是线程共享的，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。别名Non-Heap（非堆）。很多人把方法区称为“永久代”（Permanent Generation），（-XX：MaxPermSize控制上限），正逐渐废弃。JDK1.7的HotSpot中已经把原本放在永久代中的字符串常量池移出。
	当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
	
	f):运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号作用，这部分内容将在类加载后进入方法区的运行时常量池中存放。同方法区管理，会抛出OutOfMemoryError异常。

	g):直接内存：直接内存并不是虚拟机运行时数据区的一部分。会抛出OutOfMemoryError异常。不受java堆大小限制。
	
3.溢出
	a):java堆溢出
		通过参数 -XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。 
		如果出现堆区域的异常，一般的手段是通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。如果是内存泄漏。。。。，如果不存在内存泄漏。。。。（第52页）。

	b):虚拟机栈和本地方法栈溢出
		-Xss
		可以使用减少最大堆和减少栈容量的方式换取更多的线程，以这种“减少内存”的方式来解决内存溢出。
		每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

	c):方法区和常量池溢出
		intern（）方法的问题（第57页）不太明白
		String str1 = new StringBuilder("计算机").append("软件").toString();
		System.out.println(str1.intern() == str1);				//true	jdk1.7
		String str2 = new StringBuilder("ja").append("va").toString();
		System.out.println(str2.intern() == str2);				//false	jdk1.7

	d):本机直接内存溢出
		DirectMemory 容量可以通过 -XX:MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值（-Xmx指定）一样。
		由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或者间接使用了NIO，那就可以考虑检测一下是不是这方面的原因。


二、垃圾收集器与内存分配策略（第三章）
1.在java虚拟机中是通过 可达性分析 来判定对象是否存活的。
	不可达的对象要至少经历两次标记过程，判定GC Roots时第一次进行标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。不建议在代码中使用此方法，用try更好。

2.JDK1.2之后，java对引用的概念进行了扩充，由强度依次减弱，将引用分为强引用、软引用、弱引用、虚引用4种。

3.方法区（永久代）回收包括两部分：废弃常量和无用的类。

4.垃圾收集算法
	1).标记-清除算法:标记、清除效率不高，空间上会产生碎片。
	
	2).复制算法：将内存分成两份，当其中一份内存用完了时就将还存活的对象复制到另一块上（只要移动堆顶指针，按顺序分配内存即可），然后将另一块直接整个回收。折半内存，浪费内存。现在的商业虚拟机都采用这种方式回收新生代。新生代中分出一块较大的Eden空间和两块较小的Survivor空间，每次将Eden和其中一块Survivor空间还存活的对象复制到另一块Survivor空间。最后清理Eden和Survivor。如果Survivor的空间不够，这些对象直接通过分配担保进入老年代。
	当存活对象较多时，效率降低。更关键的，不想浪费50%空间就需额外空间进行分配担保。
	
	3).标记-整理算法：老年代中，标记完成后让所有存活的对象都想一端移动，然后直接清理端边界以外的内存。
	
	4).分代收集算法：当前商业虚拟机的垃圾收集都采用“分代收集”算法。根据对象存活周期的不同将内存分为几块。一般是把java堆分为新生代和老年代，然后各代采用最适当的算法。在新生代用复制算法，老年代采用“标记-清理”或者“标记-整理”算法。 

5.垃圾收集器
	所有收集器图3-5.
	各收集器的特点

6.GC日志的分析方法：3.5.8

7.垃圾收集器的参数总结：3.5.9

8.内存分配与回收策略
	对象的内存分配主要在堆上分配（但也可能经过JIT编译后被拆散为标量类型间接的栈上分配），对象主要分配在新生代的Eden区，如果启动了本地线程分配缓冲，将按线程优先在TLAB（Thread Local Allocation Buffer）上分配。少数情况下也可能直接分配在老年代中，分配的规则取决于垃圾收集器的组合和虚拟机中内存参数的设置。

	a).对象优先在Eden分配
	b).大对象直接进入老年代
	c).长期存活的对象将进入老年代
	d).动态对象年龄判定
		不一定要求对象的年龄必须达到MaxTenURingThreshold才能晋升老年代；相同年龄的对象大小大于或等于Survivor空间的一半即可。
	e).空间分配担保
		在JDK6Update24之后，改为了只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。




三、虚拟机性能监控与故障处理（第四章）
	JDK1.5的虚拟机上的程序，需要在程序启动时添加参数 -Dcom.sun.management.jmxremote 开启JMX管理功能，因为以下工具有些基于JMX。
	Sun JDK监控和故障处理工具：jps,jstat,jinfo,jmap,jhat,jstack   -----P103
	1.jps:虚拟机进程状况工具
	功能：列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID（LVMID）。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID）是一致的。

	使用：cmd进入JDKbin路径 D:\Program Files\Java\jdk1.7.0_79\bin>jps -l
	
	主要参数选项：
	-q	只输出LVMID，省略主类名称
	-m	输出虚拟机进程启动时传递给主类mian（）函数的参数
	-l	输出主类的全名，如果进程执行的是jar包，输出jar路径
	-v	输出虚拟机进程启动时JVM参数
	
	2.jstat:虚拟机统计信息监视工具
	功能：用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。是无GUI环境运行期定位虚拟机性能问题的首选工具。
	使用：具体见P105
	
	3.





四、虚拟机执行子系统
	1.类文件结构
	Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序排列，无分隔符。Class文件结构中只有两种数据类型：无符号数和表。具体类型图表：6-1 P165

	Class文件的结构：
	用十六进制打开后，开头4个字节叫“魔数”，作用是确定这个文件是否为一个能被虚拟机接收的Class文件。
	
	第5和第6个字节是次版本号(Minor Version)。
	
	第7和第8个字节是主版本号（Major Version)。   --jdk 输出的版本号的值可以使用-target进行控制   P167表6-2

	紧接着主次版本号之后的是常量池入口，可理解为Class文件中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，是Class文件中第一个出现的表类型数据项目;由于常量池中常量的数量不固定，故入口放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count，即第9和第10个字节)，从1开始。如十六进制0x0016，转成十进制22，但是代表有21项常量，规范中第0项常量空出来，目的在于满足某些指向常量池的索引值的数据“不引用任何一个常量池项目”的含义（把索引值置为0表示）。
	Class文件结构中只有常量池容量计数是从1开始，其他集合类型等都是从0开始。
	常量池中主要存放两大类常量：字面量和符号引用。Class文件不保存各个方法、字段的最终内存布局，而是虚拟机加载class文件时进行动态连接。常量池中每一项常量都是一个表，现有14种表结构，每种表开始第一位都是一个u1类型的标志位（tag，取值表6-3，即14种结构的表示码），代表这个常量属于哪种常量类型。具体见表6-3 P169    
	可以借助jdk bin中的javap工具进行分析Class文件 ：javap -verbose 文件名
	
	在常量池结束后，紧接着的两个字节代表访问标志（access_flags），用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。对应的为真或者假表示，最后计算成两位的值。具体标志及含义对应表6-7 P173
	
	接着访问标记位的是类索引(u2类型，确定类的全限定名)、父类索引(u2类型，确定父类的全限定名)和接口索引集合(一组u2类型的数据的集合，确定这个类实现了哪些接口)。Class文件由这三项来确定这个类的继承关系。
	类索引和父类索引，指向CONSTANT_Class_info的类描述符常量，常量里面的索引值记录了常量池中的哪个常量是其对应的值;对于接口索引集合，入口的第一项u2类型的数据为接口计数器，表示索引表的容量，如果没有实现接口，则值为0，后面的接口的索引表不再占用任何字节。

	接着是字段表集合，用于描述接口或者类中声明的变量。字段表结构表6-8 P176.    字段表集合第一个u2类型的数据为容量计数器，说明这个类有多少个字段表数据。字段表集合中不会列出从超类或者父类接口中继承而来的字段，但可能会列出原本java代码中不存在的字段，如，在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。（具体细节查阅书籍P175）

	接着字段表集合是方法表集合，结构几乎和字段表差不多。（具体细节查阅书籍P178）
	
	属性表P180。 java程序方法体中的代码编译后最终变为字节码存储在Code属性内。

	



	6.4--》结束 节字节码指令没看
	=========================================================================================================================
	try。。。catch。。。finally 实现：jdk1.4.2之后是编译器自动在每段可能的分支路径后都将finally语句块的内容冗余生成一遍来实现finally语义。
		public int inc() {
		int i;
		int b = 0;
		try {
			i = 1;
			int a = 10 / b;
			return i;
		} catch (Exception e) {
			System.out.println(e);
			i = 2;
			return i;
		} finally {
			i = 3;
		}
	}

	结果：这段代码如果没有异常，结果为1；如果有异常结果为2。 无论是出现异常还是没有异常，finally中的代码总是执行，但返回值是返回的复制的那一份。
		要是把return都去掉，结果无论如何都是3。
	
	
	=========================================================================================================================




	2.虚拟机类加载机制
		a.在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。
		类从被加载到虚拟机内存到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。
		加载、验证、准备、初始化和卸载5个阶段的顺序是确定的，但因为支持Java的运行时绑定，解析可以再初始化阶段之后再开始。
		虚拟机中规定初始化阶段，有且只有5种情况必须立即对类进行“初始化”。（P210） 除此之外所有引用类的方式都不会触发初始化，称为被动引用。

		加载
			加载是类加载过程的一个阶段。
			在加载阶段，虚拟机需要完成以下3件事情：
			1）.通过一个类的全限定名来获取定义此类的二进制字节流。
			2）.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
			3）.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

			加载阶段和连接阶段是交叉进行的。
		
		验证
			验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全（Class文件不一定来源自Java文件，可能会因为载入有害的字节流导致系统崩溃）。如验证字节流不符合Class文件格式，虚拟机应抛出java.lang.VerifyError异常或子类异常。
			验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。（具体细节见P216）
			
		准备
			准备阶段是正式为类变量（只是类变量，方法的局部变量不会）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值通常是数据类型的零值。例如：public static int value=123; 那变量在准备阶段过后的初始值为0而不是123.
			
		解析
			解析阶段是虚拟机将常量池内的符号引用（CONSTANT_Class_info等类型的常量）替换为直接引用的过程。
			具体见P220
		
		初始化
			类初始化阶段是类加载过程的最后一步。初始化阶段是执行类构造器<clinit>()方法的过程。其特点和细节：P225
			
	
	
		b.类加载器
			如果类是有不同的类加载器来加载的，那也是两个类，instanceof 判断时为false。
		
			双亲委派模型

	3.虚拟机字节码执行引擎
		详见P236
	
	4.类加载及执行子系统的案例与实战
		tomcat、osgi、字节码生成技术与动态代理的实现、retrotranslator。
		实战 未看。

五、程序编译与代码优化
	
	1.早期（编译期）优化
	包装类的“==”运算符在不遇到算数运算符的情况下不会自动拆箱，以及他们的equals（）方法不处理数据转型。
		Integer a = 1;
		Integer b = 2;
		Integer c = 3;
		Integer d = 3;
		Integer e = 321;
		Integer f = 321;
		Long g = 3L;

		System.out.println(c == d);
		System.out.println(e == f);
		System.out.println(c == (a + b));
		System.out.println(c.equals(a + b));
		System.out.println(g == (a + b));
		System.out.println(g.equals(a + b));

		结果：（jdk1.7）   如果把Integer改为int结果会不同
			true
			false
			true
			true
			true
			false



	实战：未看

	2.晚期（运行期）优化
		
	





















































