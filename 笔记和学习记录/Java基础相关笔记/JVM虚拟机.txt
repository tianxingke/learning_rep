常用配置：
1.显示GC日志：http://blog.csdn.net/zsy112371/article/details/44981923
2.-XX:+PrintGCDetails 虚拟机在发生垃圾收集时打印内存回收日志
------------------------------------------------------------------------------------------------------------

一、Java虚拟机运行时数据区
1.结构图片http://img.blog.csdn.net/20160801164042333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
2.运行时数据区组成：
	a).程序计数器：可以看作是当前线程所执行的字节码的行号指示器。通过改变这个计数器的值来选取下条要执行的字节码指令。分支、循环、异常等都依赖计数器。
			每个线程都有各自的计数器，互不影响，为私有内存。
			如果线程正在执行的是Java方法，则此计数器记录的是正在执行的字节码指令地址，如果是Native方法则计数器值为空。
			此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
	
	b).java虚拟机栈：Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
	局部变量表存放了编译期可知的各种基本数据类型（8种基本类型）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。
	这个区域有两种异常状态：1）如果线程请求的栈深度大雨虚拟机所允许的深度，将抛出StackOverflowError异常。2）如果动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
	
	c).本地方法栈：本地方法栈为虚拟机使用到的Native方法（字节码）服务。与虚拟机栈一样，也会抛出StackOverflowError和OutOfMemoryError异常。
	
	d).Java堆：java堆是虚拟机内存中最大的一块。是被所有的线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放（几乎所有）对象实例。
	java堆又被称为GC堆。由于现在收集器基本都是采用分代收集算法，所以java堆中可以分为新生代和老年代。从内存分配的角度来看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（TLAB）。
	java堆可以处于物理上不连续的内存空间。可扩展（通过-Xmx和-Xms控制）。
	如果堆中没有内存完成实例分配，并且也无法再扩展时，抛出OutOfMemoryError。

	e).方法区：是线程共享的，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。别名Non-Heap（非堆）。很多人把方法区称为“永久代”（Permanent Generation），（-XX：MaxPermSize控制上限），正逐渐废弃。JDK1.7的HotSpot中已经把原本放在永久代中的字符串常量池移出。
	当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
	
	f):运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号作用，这部分内容将在类加载后进入方法区的运行时常量池中存放。同方法区管理，会抛出OutOfMemoryError异常。

	g):直接内存：直接内存并不是虚拟机运行时数据区的一部分。会抛出OutOfMemoryError异常。不受java堆大小限制。
	
3.溢出
	a):java堆溢出
		通过参数 -XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。 
		如果出现堆区域的异常，一般的手段是通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。如果是内存泄漏。。。。，如果不存在内存泄漏。。。。（第52页）。

	b):虚拟机栈和本地方法栈溢出
		-Xss
		可以使用减少最大堆和减少栈容量的方式换取更多的线程，以这种“减少内存”的方式来解决内存溢出。
		每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

	c):方法区和常量池溢出
		intern（）方法的问题（第57页）不太明白
		String str1 = new StringBuilder("计算机").append("软件").toString();
		System.out.println(str1.intern() == str1);				//true	jdk1.7
		String str2 = new StringBuilder("ja").append("va").toString();
		System.out.println(str2.intern() == str2);				//false	jdk1.7

	d):本机直接内存溢出
		DirectMemory 容量可以通过 -XX:MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值（-Xmx指定）一样。
		由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或者间接使用了NIO，那就可以考虑检测一下是不是这方面的原因。


二、垃圾收集器与内存分配策略（第三章）
1.在java虚拟机中是通过 可达性分析 来判定对象是否存活的。
	不可达的对象要至少经历两次标记过程，判定GC Roots时第一次进行标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。不建议在代码中使用此方法，用try更好。

2.JDK1.2之后，java对引用的概念进行了扩充，由强度依次减弱，将引用分为强引用、软引用、弱引用、虚引用4种。

3.方法区（永久代）回收包括两部分：废弃常量和无用的类。

4.垃圾收集算法
	1).标记-清除算法:标记、清除效率不高，空间上会产生碎片。
	
	2).复制算法：将内存分成两份，当其中一份内存用完了时就将还存活的对象复制到另一块上（只要移动堆顶指针，按顺序分配内存即可），然后将另一块直接整个回收。折半内存，浪费内存。现在的商业虚拟机都采用这种方式回收新生代。新生代中分出一块较大的Eden空间和两块较小的Survivor空间，每次将Eden和其中一块Survivor空间还存活的对象复制到另一块Survivor空间。最后清理Eden和Survivor。如果Survivor的空间不够，这些对象直接通过分配担保进入老年代。
	当存活对象较多时，效率降低。更关键的，不想浪费50%空间就需额外空间进行分配担保。
	
	3).标记-整理算法：老年代中，标记完成后让所有存活的对象都想一端移动，然后直接清理端边界以外的内存。
	
	4).分代收集算法：当前商业虚拟机的垃圾收集都采用“分代收集”算法。根据对象存活周期的不同将内存分为几块。一般是把java堆分为新生代和老年代，然后各代采用最适当的算法。在新生代用复制算法，老年代采用“标记-清理”或者“标记-整理”算法。 

5.垃圾收集器
	所有收集器图3-5.
	各收集器的特点

6.GC日志的分析方法：3.5.8

7.垃圾收集器的参数总结：3.5.9

8.内存分配与回收策略
	对象的内存分配主要在堆上分配（但也可能经过JIT编译后被拆散为标量类型间接的栈上分配），对象主要分配在新生代的Eden区，如果启动了本地线程分配缓冲，将按线程优先在TLAB（Thread Local Allocation Buffer）上分配。少数情况下也可能直接分配在老年代中，分配的规则取决于垃圾收集器的组合和虚拟机中内存参数的设置。

	a).对象优先在Eden分配
	b).大对象直接进入老年代
	c).长期存活的对象将进入老年代
	d).动态对象年龄判定
		不一定要求对象的年龄必须达到MaxTenURingThreshold才能晋升老年代；相同年龄的对象大小大于或等于Survivor空间的一半即可。
	e).空间分配担保
		在JDK6Update24之后，改为了只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。




三、虚拟机性能监控与故障处理（第四章）
	JDK1.5的虚拟机上的程序，需要在程序启动时添加参数 -Dcom.sun.management.jmxremote 开启JMX管理功能，因为以下工具有些基于JMX。
	Sun JDK监控和故障处理工具：jps,jstat,jinfo,jmap,jhat,jstack   -----P103
	1.jps:虚拟机进程状况工具
	功能：列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID（LVMID）。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID）是一致的。

	使用：cmd进入JDKbin路径 D:\Program Files\Java\jdk1.7.0_79\bin>jps -l
	
	主要参数选项：
	-q	只输出LVMID，省略主类名称
	-m	输出虚拟机进程启动时传递给主类mian（）函数的参数
	-l	输出主类的全名，如果进程执行的是jar包，输出jar路径
	-v	输出虚拟机进程启动时JVM参数
	
	2.jstat:虚拟机统计信息监视工具
	功能：用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。是无GUI环境运行期定位虚拟机性能问题的首选工具。
	使用：具体见P105
	
	3.





四、虚拟机执行子系统
	1.类文件结构
	









































































