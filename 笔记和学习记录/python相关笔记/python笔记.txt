1.输入： input(), 
   输出：print()
   
2.特殊字符转义与Java基本相同，使用 /  
    可以使用 r'' ,标示‘’ 内部的内容默认不转义。
  例子：  >>> print('\\\t\\')    --转义
		\       \
	>>> print(r'\\\t\\')      --未转义
		\\\t\\

3.'''.....''' 可以标示有多行的内容。

4.布尔值： True   False   
   连接： and     or     
	not取反  例子：  not True   --False
   空值： None

5.变量名必须是大小写英文、数字和_的组合，且不能用数字开头
  除法 / 的计算结果是浮点型的，精确的，即使两个操作数均是整数且结果正好整除。
  例子：>>> 9 / 3
	3.0
	
  用  //  的除法结果是整数，即使除不尽也是整数。

6.对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：
	>>> ord('A')
	65
	>>> ord('中')
	20013
	>>> chr(66)
	'B'
	>>> chr(25991)
	'文'

	由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。
	Python对bytes类型的数据用带b前缀的单引号或双引号表示：
	x = b'ABC'
	要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。
	
	以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：
	>>> 'ABC'.encode('ascii')
	b'ABC'
	>>> '中文'.encode('utf-8')
	b'\xe4\xb8\xad\xe6\x96\x87'
	>>> '中文'.encode('ascii')
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
	纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。
	在bytes中，无法显示为ASCII字符的字节，用\x##显示。
	
	反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
	>>> b'ABC'.decode('ascii')
	'ABC'
	>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
	'中文'	
	
	为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
	#!/usr/bin/env python3
	#-*- coding: utf-8 -*-
	
7.要计算str包含多少个字符，可以用len()函数：
	>>> len('ABC')
	3
	len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：

8.格式化
	在Python中，采用的格式化方式和C语言是一致的，用%实现。
	举例如下：
	>>> 'Hello, %s' % 'world'
	'Hello, world'
	>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
	'Hi, Michael, you have $1000000.'
	你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。
	
	有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%
	
9.Python内置的一种数据类型是列表：list。
	>>> classmates = ['Michael', 'Bob', 'Tracy']
	>>> classmates
	['Michael', 'Bob', 'Tracy']
	
	如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：
	>>> classmates[-1]
	'Tracy'
	以此类推，可以获取倒数第2个、倒数第3个：
	>>> classmates[-2]
	'Bob'
	>>> classmates[-3]
	'Michael'
	list是一个可变的有序表，所以，可以往list中追加元素到末尾：
	>>> classmates.append('Adam')	
	也可以把元素插入到指定的位置，比如索引号为1的位置，原本位置的元素会后移：
	>>> classmates.insert(1, 'Jack')
	要删除list末尾的元素，用pop()方法
	要删除指定位置的元素，用pop(i)方法，其中i是索引位置
	要把某个元素替换成别的元素，可以直接赋值给对应的索引位置
	list里面的元素的数据类型也可以不同
	list元素也可以是另一个list，比如：
	>>> s = ['python', 'java', ['asp', 'php'], 'scheme']
	>>> len(s)
	4
	
	也可以：>>> p = ['asp', 'php']
			>>> s = ['python', 'java', p, 'scheme']
	要拿到'php'可以写p[1]或者s[2][1]。
	如果一个list中一个元素也没有，就是一个空的list，它的长度为0：
	>>> L = []
	>>> len(L)
	0
	

	Python列表操作的函数和方法
		列表操作包含以下函数:
		1、可以用表达式(a > b) - (a < b)代替cmp(a,b) 。 Python3中没有这个函数了
		2、len(list)：列表元素个数 
		3、max(list)：返回列表元素最大值 
		4、min(list)：返回列表元素最小值 
		5、list(seq)：将元组转换为列表 
		列表操作包含以下方法:
		1、list.append(obj)：在列表末尾添加新的对象
		2、list.count(obj)：统计某个元素在列表中出现的次数，统计是按元素整体来进行的，不是根据元素里边的字符
		3、list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
		4、list.index(obj)：从列表中找出某个值第一个匹配项的索引位置，是按元素整体进行查找的。
		5、list.insert(index, obj)：将对象插入列表
		6、list.pop()：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
		7、list.remove(obj)：移除列表中某个值的第一个匹配项
		8、list.reverse()：反向列表中元素
		9、list.sort([func])：对原列表进行排序

	
	
	另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，
	>>> classmates = ('Michael', 'Bob', 'Tracy')    
	现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，但是无法赋值。
	
	只有1个元素的tuple定义时必须加一个逗号,，来消除歧义，因为不加逗号会当成数学上的小括号进行计算的：
	>>> t = (1,)
	tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！
	
	元组中的元素值是不允许修改的，但我们可以对元组进行连接组合：tup3 = tup1 + tup2;
	元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组：del tup;
	内置函数tuple(list1)可将列表转化为元组。
	
	
	
10.条件判断
	elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：
	if <条件判断1>:
		<执行1>
	elif <条件判断2>:
		<执行2>
	elif <条件判断3>:
		<执行3>
	else:
		<执行4>

	if  :
	
	或者
	if  :
	else:
	
	或者
	if :
	elif :
	else:
	
	if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else.
	if判断条件还可以简写，比如写：
	if x:
		print('True')
	只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。
	
11.	input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数
	如:s = input('birth: ')
	birth = int(s)
	
12.循环
	Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：
	names = ['Michael', 'Bob', 'Tracy']
	for name in names:
		print(name)
	
	幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：
	>>> list(range(5))
	[0, 1, 2, 3, 4]
	
	
	第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：
	sum = 0
	n = 99
	while n > 0:
		sum = sum + n
		n = n - 2
	print(sum)
	
13.dict
	Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。
	>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
	>>> d['Michael']
	95
	把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
	>>> d['Adam'] = 67
	>>> d['Adam']
	67
	
	要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：
	>>> 'Thomas' in d
	False
	二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：
	>>> d.get('Thomas')
	>>> d.get('Thomas', -1)
	-1
	注意：返回None的时候Python的交互式命令行不显示结果。
	
	要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
	>>> d.pop('Bob')
	
	请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

	和list比较，dict有以下几个特点：
	查找和插入的速度极快，不会随着key的增加而变慢；
	需要占用大量的内存，内存浪费多。
	而list相反：
	查找和插入的时间随着元素的增加而增加；
	占用空间小，浪费内存很少。
	所以，dict是用空间来换取时间的一种方法。
	dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。
	这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。
	要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：
	
	
	
	
	set
	set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
	要创建一个set，需要提供一个list作为输入集合：
	>>> s = set([1, 2, 3])
	>>> s
	{1, 2, 3}
	注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。
	重复元素在set中自动被过滤：
	>>> s = set([1, 1, 2, 2, 3, 3])
	>>> s
	{1, 2, 3}
	
	通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：
	>>> s.add(4)
	>>> s
	{1, 2, 3, 4}
	
	通过remove(key)方法可以删除元素：
	>>> s.remove(4)
	>>> s
	{1, 2, 3}
		
	set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：
	>>> s1 = set([1, 2, 3])
	>>> s2 = set([2, 3, 4])
	>>> s1 & s2
	{2, 3}
	>>> s1 | s2
	{1, 2, 3, 4}
	
	
	set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。
	
	>>> a = 'abc'
	>>> a.replace('a', 'A')
	'Abc'
	>>> a
	'abc'
	对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
	
14.函数
	abs(xx);
	max(xx,xx,xx,xx);
	int(xx);
	float(xx);
	str(xx);
	bool(xx);
	函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
	>>> a = abs # 变量a指向abs函数
	>>> a(-1) # 所以也可以通过a调用abs函数
	1
	
	
	在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。
	我们以自定义一个求绝对值的my_abs函数为例：
	def my_abs(x):
		if x >= 0:
			return x
		else:
			return -x
	
	如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。
	return None可以简写为return。
	
	如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）
	
	
	空函数
	如果想定义一个什么事也不做的空函数，可以用pass语句：
	def nop():
		pass
	实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。
	pass还可以用在其他语句里，比如：
	if age >= 18:
		pass
	
	参数检测
	让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：
	def my_abs(x):
		if not isinstance(x, (int, float)):
			raise TypeError('bad operand type')
		if x >= 0:
			return x
		else:
			return -x
		
	
	函数可以返回多个值吗？答案是肯定的。
	比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：
	import math
	def move(x, y, step, angle=0):
		nx = x + step * math.cos(angle)
		ny = y - step * math.sin(angle)
		return nx, ny
	>>> x, y = move(100, 100, 60, math.pi / 6)
	>>> print(x, y)
	原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。
	
	
	函数参数
	由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：
	def power(x, n=2):
		s = 1
		while n > 0:
			n = n - 1
			s = s * x
		return s
	这样，当我们调用power(5)时，相当于调用power(5, 2)：
	默认参数可以简化函数的调用。设置默认参数时，有几点要注意：
	一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
	二是如何设置默认参数。
	当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
	Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。
	所以，定义默认参数要牢记一点：默认参数必须指向不变对象！
	
	
	把函数的参数改为可变参数：
	def calc(*numbers):
		sum = 0
		for n in numbers:
			sum = sum + n * n
		return sum
	定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：
	
	Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：
	>>> nums = [1, 2, 3]
	>>> calc(*nums)
	14
	
	关键字参数
	可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：
	def person(name, age, **kw):
		print('name:', name, 'age:', age, 'other:', kw)
	
	可以只传入必选参数，也可以传入任意个数的关键字参数：
	>>> person('Bob', 35, city='Beijing')
	name: Bob age: 35 other: {'city': 'Beijing'}
	>>> person('Adam', 45, gender='M', job='Engineer')
	name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
	关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。
	和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：
	>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
	>>> person('Jack', 24, city=extra['city'], job=extra['job'])
	name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
	当然，上面复杂的调用可以用简化的写法：
	>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
	>>> person('Jack', 24, **extra)
	name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
	**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。
	
	命名关键字参数
	如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
	def person(name, age, *, city, job):
		print(name, age, city, job)
	和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。
	调用方式如下：
	>>> person('Jack', 24, city='Beijing', job='Engineer')
	Jack 24 Beijing Engineer
	
	
	递归函数
	尾递归
	
15.高级特性
	切片
	取前3个元素，用一行代码就可以完成切片：
	>>> L[0:3]
	['Michael', 'Sarah', 'Tracy']
	L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。

	如果第一个索引是0，还可以省略：
	>>> L[:3]
	['Michael', 'Sarah', 'Tracy']
	
	类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：
	>>> L[-2:]
	['Bob', 'Jack']
	>>> L[-2:-1]
	['Bob']
	记住倒数第一个元素的索引是-1。
	
	
	前10个数，每两个取一个：
	>>> L[:10:2]
	[0, 2, 4, 6, 8]
	所有数，每5个取一个：
	>>> L[::5]
	[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
	
	甚至什么都不写，只写[:]就可以原样复制一个list：
	>>> L[:]
	[0, 1, 2, 3, ..., 99]
	
	
	tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：
	>>> (0, 1, 2, 3, 4, 5)[:3]
	(0, 1, 2)
	
	
	
	字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
	>>> 'ABCDEFG'[:3]
	'ABC'
	>>> 'ABCDEFG'[::2]
	'ACEG'
	Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。
	
16.迭代
	在Python中，迭代是通过for ... in来完成的
	默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。
	由于字符串也是可迭代对象，因此，也可以作用于for循环：
	>>> for ch in 'ABC':
	...     print(ch)
	
	那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：
	>>> from collections import Iterable
	>>> isinstance('abc', Iterable) # str是否可迭代
	True
	>>> isinstance([1,2,3], Iterable) # list是否可迭代
	True
	>>> isinstance(123, Iterable) # 整数是否可迭代
	False
	
	
	最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
	>>> for i, value in enumerate(['A', 'B', 'C']):
	...     print(i, value)
	...
	0 A
	1 B
	2 C
	
17.列表生成式
	列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。
	举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：
	>>> list(range(1, 11))
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	
	写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来
	
	如果要生成[1x1, 2x2, 3x3, ..., 10x10]
	方法一是循环：
	>>> L = []
	>>> for x in range(1, 11):
	...    L.append(x * x)
	>>> L
	[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
	列表生成式则可以用一行语句代替循环生成上面的list：
	>>> [x * x for x in range(1, 11)]
	[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
	
	for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：
	>>> [x * x for x in range(1, 11) if x % 2 == 0]
	[4, 16, 36, 64, 100]
	
	还可以使用两层循环，可以生成全排列：
	>>> [m + n for m in 'ABC' for n in 'XYZ']
	['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
	
	运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：
	>>> import os # 导入os模块，模块的概念后面讲到
	>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
	
	
	列表生成式也可以使用两个变量来生成list：
	>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
	>>> [k + '=' + v for k, v in d.items()]
	['y=B', 'x=A', 'z=C']
	
	把一个list中所有的字符串变成小写：
	>>> L = ['Hello', 'World', 'IBM', 'Apple']
	>>> [s.lower() for s in L]
	['hello', 'world', 'ibm', 'apple']
	
18.生成器
	
	
	
===================================================================================================	
	签到：http://blog.csdn.net/u283056051/article/details/49946981
http://blog.csdn.net/liushuaikobe/article/details/8198992
http://blog.csdn.net/u013640004/article/details/52677804
http://www.shaoqun.com/a/99335.aspx
http://tieba.baidu.com/p/4739434662